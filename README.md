# Borys Banaszkiewicz - Distributed System using gRPC

## Description
This program is an implementation of a Distributed System using gRPC. There are 2 separate client classes implemented, 
Client and Client2. Client is not using a Registry and offers Joke, Echo, Encryption, Hometowns, and Billpay services. 
Joke has the functionality of either asking user to provide a joke or providing the user with a joke. Echo just echo's 
client message. (Both of these are not touched from initial implementation, I left them alone and are functioning exactly
the same way they were as the starter code provided). 

Encryption service is implemented to accept a message from the user along with a selection of the algorithm to use 
(Caesar Cipher is option ALGO0, XOR Cipher is option ALGO1 - both algorithms were taken from doing some research, 
sources provided below). The provided string is then encrypted using the chosen algorithm and the encrypted string is 
provided back to the client. The user can choose to decrypt as well, and this works only for the string that was 
encrypted with that same algorithm (user chooses algorithm for decryption as well) and the decrypted message is then 
sent back to the client which is then displayed to the user. 

Hometowns service allows a user to either see all hometown information which includes a persons name, the city they live
in, and the region of that city. The hometown information is returned as a Hometown repeated list that the client displays
to the user. The user can also request to search a hometown by the name of the city, which then returns all the Hometown
entries that match the given city, or if there are no hometowns matching that city then an error message is returned to 
let the user know. Lastly the user can add a hometown by giving a name, a city and a region. This is checked against 
duplicates and will let the user know if their request is successful or if it's a duplicate.

The last service offered is a Billpay service where the user has 4 options: they can see all their bills, they can request
to see the bills before a certain due date by specifying the date, they can request to pay a bill, or they can request to
add a new bill. The first option returns all the bills that the server has stored. When requesting to see bills before
a certain due date, the server will only send back bills that are due before the given date. When requesting to pay a bill,
a payment will only be accepted if its positive and if its less than or equal to the total amount due. The server will
catch if the amount is either too much or if its negative and respond with a message to let the client know. Once a payment
is approved, it will be updated on the server side to show the new amount due, or if it was paid off in full then the 
server will remove that bill from its database and let the client know that the bill was fully paid off. When adding a 
new bill, the user has to provide the vendor name, the total amount on the bill, and the due date. Duplicate vendors for 
the same month will be denied by the server with a message. The only duplicate vendors that are allowed are if they are 
each in a unique month. 

Any required user input has instructions for format and type of input in the command message. (ex: when wanting to see 
bills due before a certain date, the command output will say "enter in format MM/DD/YYYY").

### Sources for Caesar Cipher and XOR Cipher algorithms.
[Caesar Cipher](https://www.baeldung.com/java-caesar-cipher)   
[XOR Cipher](https://www.geeksforgeeks.org/xor-cipher/)   


## Screencast
[Screencast](https://drive.google.com/file/d/1UCFeqCSlfAP_6oPiFhN0UH_BXRCjP7nj/view?usp=share_link)


## How to run the program
The proto file can be compiled using
``gradle generateProto``

This will also be done when building the project.

You can see the compiled proto file in Java under build/generated/source/proto/main/java/buffers

For running things locally without using a registry, you can run the client and node by following these instructions:
* Please run `gradle runClient` and `gradle runNode` together for default local port and host.
  * NOTE: Client has the following acceptable parameters that are optional, but you can specify if you prefer: serviceHost,
servicePort, registryHost, grpcPort, message, regOn, auto.
  * The tests are automated and will stimulate the different scenarios by outputting details in the terminal. To run the
  tests, use the command `gradle runClient -Pauto=1` instead. (Please note that this will only work once
  to show correct expected output, as when its ran a second time the data generated by the tests is stored in the data
  files so duplicates will cause different output then what's listed in the automated run. This command was created to be
  run once for grading purposes).


  * NOTE: Just like Client, Node has the following acceptable parameters that are optional, but you can specify if you prefer: registryHost,
    grpcPort, serviceHost, servicePort, nodeName, regOn.


For running things with a registry, you can follow these instructions:
* Please run `gradle runRegistryServer`, `gradle runNode -PnodeName=name -PregOn=true`, and `gradle runClient2`together 
for default local port and host. (Note that Client2 automatically runs with the registry flag set to on so no need to specify it)

### gradle runRegistryServer

Will run the Registry node on localhost (arguments are possible see gradle). This node will run and allows nodes to
register themselves.
The Server allows Protobuf, JSON and gRPC. We will only be using gRPC

### gradle runNode

Will run a node with Joke, Echo, Encryption, Hometowns, and Billpay services. The node registers itself on the Registry. 
You can change the host and port the node runs on and this will register accordingly with the Registry

### gradle runClient

Will run a client which will call the services from the node, it talks to the node directly not through the registry.

### gradle runClient2

Will run a client which will call the services through the registry.
